/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * Integration tests for the /api/evaluate SSE endpoint
 *
 * Tests the full HTTP cycle:
 *   POST /api/evaluate  →  SSE 'completed' event  →  GET /api/storage/runs/by-test-case/:id
 *
 * The tests use the built-in 'demo' agent (MockConnector) and 'demo-model' (demo judge
 * provider) so that no real agent endpoint or AWS Bedrock credentials are required.
 * Only an OpenSearch storage cluster is needed.
 *
 * Requirements:
 *   - Backend server running:  npm run dev:server
 *   - OpenSearch storage:      OPENSEARCH_STORAGE_ENDPOINT env var configured
 *
 * Run:
 *   npm run test:integration -- --testPathPattern=evaluation.integration
 */

const TEST_TIMEOUT = 60000;

const getTestConfig = () => ({
  backendUrl: process.env.TEST_BACKEND_URL || 'http://localhost:4001',
});

const checkBackend = async (backendUrl: string): Promise<boolean> => {
  try {
    const response = await fetch(`${backendUrl}/health`);
    return response.ok;
  } catch {
    return false;
  }
};

const checkStorage = async (backendUrl: string): Promise<boolean> => {
  try {
    const response = await fetch(`${backendUrl}/api/storage/health`);
    if (!response.ok) return false;
    const data = await response.json();
    return data.status === 'ok';
  } catch {
    return false;
  }
};

/**
 * Consume a server-sent events response body and return all parsed event objects.
 * The server closes the stream with res.end() so this reads until done.
 */
async function consumeSSEStream(response: Response): Promise<any[]> {
  const reader = response.body?.getReader();
  if (!reader) return [];

  const decoder = new TextDecoder();
  let buffer = '';
  const events: any[] = [];

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    buffer += decoder.decode(value, { stream: true });

    // SSE events are separated by double newlines
    const parts = buffer.split('\n\n');
    buffer = parts.pop() || ''; // Keep last potentially-incomplete chunk

    for (const part of parts) {
      const dataLine = part.split('\n').find(l => l.startsWith('data: '));
      if (dataLine) {
        try {
          events.push(JSON.parse(dataLine.slice(6)));
        } catch {
          // Ignore malformed JSON
        }
      }
    }
  }

  // Process any remaining buffer content
  if (buffer.trim()) {
    const dataLine = buffer.split('\n').find(l => l.startsWith('data: '));
    if (dataLine) {
      try {
        events.push(JSON.parse(dataLine.slice(6)));
      } catch { /* ignore */ }
    }
  }

  return events;
}

/**
 * Build a minimal inline test case for ad-hoc evaluation.
 * Using expectedOutcomes so the judge has something to evaluate against.
 */
function buildInlineTestCase(testCaseId: string) {
  const now = new Date().toISOString();
  return {
    id: testCaseId,
    name: `Integration Test Case ${testCaseId}`,
    description: 'Generated by evaluate route integration test',
    labels: ['category:Test'],
    category: 'Test',
    difficulty: 'Medium',
    currentVersion: 1,
    versions: [{
      version: 1,
      createdAt: now,
      initialPrompt: 'Check the cluster health and identify any issues.',
      context: [],
      expectedOutcomes: ['The agent should identify the cluster status'],
    }],
    isPromoted: false,
    createdAt: now,
    updatedAt: now,
    initialPrompt: 'Check the cluster health and identify any issues.',
    context: [],
    expectedOutcomes: ['The agent should identify the cluster status'],
  };
}

describe('Evaluate Route Integration Tests', () => {
  let backendAvailable = false;
  let storageAvailable = false;
  let config: ReturnType<typeof getTestConfig>;
  const createdReportIds: string[] = [];

  beforeAll(async () => {
    config = getTestConfig();
    backendAvailable = await checkBackend(config.backendUrl);
    if (!backendAvailable) {
      console.warn(
        'Backend not available at',
        config.backendUrl,
        '- skipping evaluate route integration tests'
      );
      return;
    }
    storageAvailable = await checkStorage(config.backendUrl);
    if (!storageAvailable) {
      console.warn('OpenSearch storage not available - skipping evaluate route integration tests');
    }
  }, TEST_TIMEOUT);

  afterAll(async () => {
    if (!backendAvailable || !storageAvailable) return;
    // Clean up any reports created during tests
    for (const id of createdReportIds) {
      try {
        await fetch(`${config.backendUrl}/api/storage/runs/${id}`, { method: 'DELETE' });
      } catch {
        // Ignore cleanup errors
      }
    }
  }, TEST_TIMEOUT);

  // ---------------------------------------------------------------------------
  // Validation (no storage required — errors return before storage check)
  // ---------------------------------------------------------------------------

  describe('POST /api/evaluate - request validation', () => {
    it(
      'should return 400 when agentKey is missing',
      async () => {
        if (!backendAvailable) return;

        const response = await fetch(`${config.backendUrl}/api/evaluate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ testCaseId: 'some-id', modelId: 'demo-model' }),
        });

        expect(response.status).toBe(400);
        const data = await response.json();
        expect(data.error).toMatch(/agentKey/);
      },
      TEST_TIMEOUT
    );

    it(
      'should return 400 when neither testCaseId nor testCase is provided',
      async () => {
        if (!backendAvailable) return;

        const response = await fetch(`${config.backendUrl}/api/evaluate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ agentKey: 'demo', modelId: 'demo-model' }),
        });

        expect(response.status).toBe(400);
      },
      TEST_TIMEOUT
    );

    it(
      'should return 400 when agentKey refers to an unknown agent',
      async () => {
        if (!backendAvailable) return;

        const testCaseId = `tc-eval-integ-${Date.now()}`;
        const testCase = buildInlineTestCase(testCaseId);

        const response = await fetch(`${config.backendUrl}/api/evaluate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            testCase,
            agentKey: 'nonexistent-agent-xyz',
            modelId: 'demo-model',
          }),
        });

        expect(response.status).toBe(400);
        const data = await response.json();
        expect(data.error).toContain('Agent not found');
      },
      TEST_TIMEOUT
    );
  });

  // ---------------------------------------------------------------------------
  // Happy path (requires storage)
  // ---------------------------------------------------------------------------

  describe('POST /api/evaluate - happy path', () => {
    it(
      'should return 200 with SSE content-type and stream started + completed events',
      async () => {
        if (!backendAvailable || !storageAvailable) return;

        const testCaseId = `tc-eval-integ-${Date.now()}`;
        const testCase = buildInlineTestCase(testCaseId);

        const response = await fetch(`${config.backendUrl}/api/evaluate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            testCase,
            agentKey: 'demo',
            modelId: 'demo-model',
          }),
        });

        expect(response.status).toBe(200);
        expect(response.headers.get('content-type')).toMatch(/text\/event-stream/);

        const events = await consumeSSEStream(response);

        const startedEvent = events.find(e => e.type === 'started');
        const completedEvent = events.find(e => e.type === 'completed');

        expect(startedEvent).toBeDefined();
        expect(startedEvent.testCase).toBeDefined();
        expect(startedEvent.agent).toBeDefined();

        expect(completedEvent).toBeDefined();
        expect(completedEvent.reportId).toBeDefined();
        expect(typeof completedEvent.reportId).toBe('string');
        expect(completedEvent.report).toBeDefined();
        expect(completedEvent.report.status).toBe('completed');

        createdReportIds.push(completedEvent.reportId);
      },
      TEST_TIMEOUT
    );

    it(
      'should save the run so it is retrievable via GET /api/storage/runs/by-test-case/:id',
      async () => {
        if (!backendAvailable || !storageAvailable) return;

        const testCaseId = `tc-eval-integ-${Date.now()}`;
        const testCase = buildInlineTestCase(testCaseId);

        // 1. Run the evaluation
        const evalResponse = await fetch(`${config.backendUrl}/api/evaluate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            testCase,
            agentKey: 'demo',
            modelId: 'demo-model',
          }),
        });

        expect(evalResponse.status).toBe(200);

        const events = await consumeSSEStream(evalResponse);
        const completedEvent = events.find(e => e.type === 'completed');

        expect(completedEvent).toBeDefined();
        const reportId: string = completedEvent.reportId;
        createdReportIds.push(reportId);

        // 2. Verify the run is retrievable by test case ID
        const runsResponse = await fetch(
          `${config.backendUrl}/api/storage/runs/by-test-case/${testCaseId}`
        );

        expect(runsResponse.status).toBe(200);

        const runsData = await runsResponse.json();
        const savedRun = runsData.runs.find((r: any) => r.id === reportId);

        expect(savedRun).toBeDefined();
        expect(savedRun.testCaseId).toBe(testCaseId);
        expect(savedRun.status).toBe('completed');
      },
      TEST_TIMEOUT
    );

    it(
      'should include trajectory steps events in the SSE stream',
      async () => {
        if (!backendAvailable || !storageAvailable) return;

        const testCaseId = `tc-eval-integ-${Date.now()}`;
        const testCase = buildInlineTestCase(testCaseId);

        const evalResponse = await fetch(`${config.backendUrl}/api/evaluate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            testCase,
            agentKey: 'demo',
            modelId: 'demo-model',
          }),
        });

        const events = await consumeSSEStream(evalResponse);
        const stepEvents = events.filter(e => e.type === 'step');
        const completedEvent = events.find(e => e.type === 'completed');

        // The MockConnector emits several trajectory steps
        expect(stepEvents.length).toBeGreaterThan(0);

        if (completedEvent?.reportId) {
          createdReportIds.push(completedEvent.reportId);
        }
      },
      TEST_TIMEOUT
    );
  });

  // ---------------------------------------------------------------------------
  // Error path — verify no phantom runs are saved on pre-SSE failures
  // ---------------------------------------------------------------------------

  describe('POST /api/evaluate - error path', () => {
    it(
      'should not save any run when the agent is not found (pre-SSE error)',
      async () => {
        if (!backendAvailable || !storageAvailable) return;

        const testCaseId = `tc-eval-integ-${Date.now()}`;
        const testCase = buildInlineTestCase(testCaseId);

        // Trigger a pre-SSE 400 error
        await fetch(`${config.backendUrl}/api/evaluate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            testCase,
            agentKey: 'nonexistent-agent-xyz',
            modelId: 'demo-model',
          }),
        });

        // Verify no run was persisted for this unique test case ID
        const runsResponse = await fetch(
          `${config.backendUrl}/api/storage/runs/by-test-case/${testCaseId}`
        );
        const runsData = await runsResponse.json();
        const matchingRuns = (runsData.runs as any[]).filter(
          r => r.testCaseId === testCaseId
        );

        expect(matchingRuns).toHaveLength(0);
      },
      TEST_TIMEOUT
    );
  });
});
